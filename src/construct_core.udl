namespace construct_core {};

dictionary RegistrationBundleJson {
    string identity_public;
    string signed_prekey_public;
    string signature;
    string verifying_key;
    string suite_id;
};

dictionary EncryptedMessageComponents {
    sequence<u8> ephemeral_public_key;
    u32 message_number;
    string content;
};

dictionary SessionInitResult {
    string session_id;
    string decrypted_message;
};

dictionary PrivateKeysJson {
    string identity_secret;
    string signing_secret;
    string signed_prekey_secret;
    string prekey_signature;
    string suite_id;
};

[Error]
enum CryptoError {
    "InitializationFailed",
    "SessionNotFound",
    "SessionInitializationFailed",
    "EncryptionFailed",
    "DecryptionFailed",
    "InvalidKeyData",
    "InvalidCiphertext",
    "SerializationFailed",
    "MessagePackDeserializationFailed",
};

interface ClassicCryptoCore {
    [Throws=CryptoError]
    string export_registration_bundle_json();

    [Throws=CryptoError]
    string sign_bundle_data(sequence<u8> bundle_data_json);

    [Throws=CryptoError]
    string export_private_keys_json();

    [Throws=CryptoError]
    string export_session_json(string contact_id);

    [Throws=CryptoError]
    string import_session_json(string contact_id, string session_json);

    sequence<string> get_all_session_contact_ids();

    [Throws=CryptoError]
    string init_session(string contact_id, sequence<u8> recipient_bundle);

    [Throws=CryptoError]
    SessionInitResult init_receiving_session(string contact_id, sequence<u8> recipient_bundle, sequence<u8> first_message);

    [Throws=CryptoError]
    EncryptedMessageComponents encrypt_message(string session_id, string plaintext);

    [Throws=CryptoError]
    string decrypt_message(string session_id, sequence<u8> ephemeral_public_key, u32 message_number, string content);

    boolean remove_session(string contact_id);
};

// ============================================================================
// Traffic Protection (Cover Traffic & Timing)
// ============================================================================

dictionary CoverTrafficConfig {
    boolean enabled;
    float battery_level_threshold;
    u64 min_interval_ms;
    u64 max_interval_ms;
    u64 message_size;
    boolean coalesce_with_real_messages;
    u64 coalesce_window_ms;
};

dictionary EnergyMetrics {
    u64 dummies_sent;
    u64 coalesced_count;
    u64 battery_skipped;
};

dictionary TimingConfig {
    u64 heartbeat_interval_sec;
    u64 heartbeat_jitter_ms;
    u64 max_send_delay_ms;
    boolean enabled;
    boolean battery_aware;
};

interface TrafficProtectionManager {
    constructor(CoverTrafficConfig config);

    void update_battery_level(float level);
    void record_real_message_sent();
    boolean should_send_dummy();
    sequence<u8> generate_dummy();
    EnergyMetrics get_metrics();
    void reset_metrics();
    u64 current_interval_ms();
    boolean is_currently_active();
};

namespace construct_core {
    [Throws=CryptoError]
    ClassicCryptoCore create_crypto_core();

    [Throws=CryptoError]
    ClassicCryptoCore create_crypto_core_from_keys_json(string keys_json);

    // Traffic Protection Functions
    sequence<u8> generate_dummy_message(u64 size);
    boolean is_dummy_message(sequence<u8> data);

    // Timing Functions
    u64 jittered_interval_ms(u64 base_ms, u64 jitter_ms);
    u64 random_send_delay_ms(u64 max_delay_ms);
    u64 heartbeat_interval_ms(u64 base_interval_sec);
    u64 battery_aware_jitter_ms(u64 base_ms, u64 max_jitter_ms, float battery_level);
    u64 recommended_send_delay_ms(boolean is_high_priority, float battery_level);
};
