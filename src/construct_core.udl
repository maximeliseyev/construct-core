namespace construct_core {
    // Device ID functions
    string derive_device_id(sequence<u8> identity_public_key);
    string format_federated_id(string device_id, string server_hostname);
    
    // Proof of Work functions
    PowSolution compute_pow(string challenge, u32 difficulty);
    PowSolution compute_pow_with_progress(
        string challenge,
        u32 difficulty,
        PowProgressCallback? progress_callback
    );
    boolean verify_pow(string challenge, PowSolution solution, u32 required_difficulty);
};

// ============================================================================
// Device-Based Authentication
// ============================================================================

dictionary PowChallenge {
    string challenge;
    u32 difficulty;
    i64 expires_at;
};

dictionary PowSolution {
    u64 nonce;
    string hash;
};

callback interface PowProgressCallback {
    void on_progress(u64 current_nonce, u64 attempts, f32 estimated_progress);
};

// ============================================================================
// Registration & Key Bundles
// ============================================================================

dictionary RegistrationBundleJson {
    string identity_public;
    string signed_prekey_public;
    string signature;
    string verifying_key;
    string suite_id;
};

dictionary EncryptedMessageComponents {
    sequence<u8> ephemeral_public_key;
    u32 message_number;
    string content;
};

dictionary SessionInitResult {
    string session_id;
    string decrypted_message;
};

dictionary PrivateKeysJson {
    string identity_secret;
    string signing_secret;
    string signed_prekey_secret;
    string prekey_signature;
    string suite_id;
};

[Error]
enum CryptoError {
    "InitializationFailed",
    "SessionNotFound",
    "SessionInitializationFailed",
    "EncryptionFailed",
    "DecryptionFailed",
    "InvalidKeyData",
    "InvalidCiphertext",
    "SerializationFailed",
    "MessagePackDeserializationFailed",
};

interface ClassicCryptoCore {
    [Throws=CryptoError]
    string export_registration_bundle_json();

    [Throws=CryptoError]
    string sign_bundle_data(sequence<u8> bundle_data_json);

    [Throws=CryptoError]
    string export_private_keys_json();

    [Throws=CryptoError]
    string export_session_json(string contact_id);

    [Throws=CryptoError]
    string import_session_json(string contact_id, string session_json);

    sequence<string> get_all_session_contact_ids();

    [Throws=CryptoError]
    string init_session(string contact_id, sequence<u8> recipient_bundle);

    [Throws=CryptoError]
    SessionInitResult init_receiving_session(string contact_id, sequence<u8> recipient_bundle, sequence<u8> first_message);

    [Throws=CryptoError]
    EncryptedMessageComponents encrypt_message(string session_id, string plaintext);

    [Throws=CryptoError]
    string decrypt_message(string session_id, sequence<u8> ephemeral_public_key, u32 message_number, string content);

    boolean remove_session(string contact_id);
};

// ============================================================================
// Invite Crypto (Dynamic Contact Invites)
// ============================================================================

dictionary EphemeralKeyPair {
    sequence<u8> secret_key;
    sequence<u8> public_key;
};

dictionary InviteSignature {
    sequence<u8> signature;
};

// ============================================================================
// Traffic Protection (Cover Traffic & Timing)
// ============================================================================

dictionary CoverTrafficConfig {
    boolean enabled;
    float battery_level_threshold;
    u64 min_interval_ms;
    u64 max_interval_ms;
    u64 message_size;
    boolean coalesce_with_real_messages;
    u64 coalesce_window_ms;
};

dictionary EnergyMetrics {
    u64 dummies_sent;
    u64 coalesced_count;
    u64 battery_skipped;
};

dictionary TimingConfig {
    u64 heartbeat_interval_sec;
    u64 heartbeat_jitter_ms;
    u64 max_send_delay_ms;
    boolean enabled;
    boolean battery_aware;
};

interface TrafficProtectionManager {
    constructor(CoverTrafficConfig config);

    void update_battery_level(float level);
    void record_real_message_sent();
    boolean should_send_dummy();
    sequence<u8> generate_dummy();
    EnergyMetrics get_metrics();
    void reset_metrics();
    u64 current_interval_ms();
    boolean is_currently_active();
};

namespace construct_core {
    [Throws=CryptoError]
    ClassicCryptoCore create_crypto_core();

    [Throws=CryptoError]
    ClassicCryptoCore create_crypto_core_from_keys_json(string keys_json);

    // Invite Crypto Functions
    [Throws=CryptoError]
    EphemeralKeyPair generate_ephemeral_keypair();
    
    [Throws=CryptoError]
    InviteSignature sign_invite_data(string data, sequence<u8> identity_secret_key);
    
    [Throws=CryptoError]
    boolean verify_invite_signature(string data, sequence<u8> signature, sequence<u8> verifying_key);
    
    [Throws=CryptoError]
    sequence<u8> derive_verifying_key_from_secret(sequence<u8> identity_secret_key);

    // Traffic Protection Functions
    sequence<u8> generate_dummy_message(u64 size);
    boolean is_dummy_message(sequence<u8> data);

    // Timing Functions
    u64 jittered_interval_ms(u64 base_ms, u64 jitter_ms);
    u64 random_send_delay_ms(u64 max_delay_ms);
    u64 heartbeat_interval_ms(u64 base_interval_sec);
    u64 battery_aware_jitter_ms(u64 base_ms, u64 max_jitter_ms, float battery_level);
    u64 recommended_send_delay_ms(boolean is_high_priority, float battery_level);
};
